\input{bachelor-praeambel.tex} % Importiere die Einstellungen aus der Präambel
% hier beginnt der eigentliche Inhalt
\begin{document}
\pagenumbering{Roman} % große Römische Seitenummerierung
\pagestyle{empty}

% Titelseite
\clearscrheadings\clearscrplain

\begin{center}
\begin{Huge}
Institut für Mathematik und Informatik\\
\vspace{3mm}
\end{Huge}{\Large Fernuniversiät Hagen}\\

\vspace{20mm}
\begin{Large}
Vergleichende Implementierung und Evaluierung einer ereignisgesteuerten, nicht
blockierenden I/O Lösung für eine datenintensive Real-Time Webanwendung in Javascript
und Dart\\
\end{Large}
\vspace{8mm}
Bachelorarbeit\\
\vspace{0.4cm}
\vspace{2 cm}
Barbara Drüke \\
Matrikel-Nummer 7397860\\
\vspace{5cm}
\begin{tabular}{ll}
{\bf Betreuer} & Dr. Jörg Brunsmann\\
{\bf Erstprüfer}&Prof. Hemmje\\
{\bf Zweitprüfer}&Dr. Jörg Brunsmann\\
\end{tabular}

\end{center}
\clearpage


\pagestyle{useheadings} % normale Kopf- und Fußzeilen für den Rest

\tableofcontents
\listoffigures
\listoftables





% richtiger Inhalt
%---------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Einleitung}
\pagenumbering{arabic} % ab jetzt die normale arabische Nummerierung

Die Vesseltracker.com GmbH ist ein Schiffsmonitoring und -reporting-Dienstleister. Der kostenpflichtige Dienst stellt den Kunden umfangreiche Informationen zu Schiffen weltweit zur Verfügung. Dabei handelt es sich einerseits um Schiffs-Stammdaten und andererseits um Schiffs-Postionsdaten. Die Positionsdaten sind AIS (Automatic Identification System) -Daten, wie sie von allen Schiffen über Funk regelmäßig zu senden sind.

\begin{wrapfigure}{r}{0.6\textwidth}
  \begin{center}
    \includegraphics[width=0.58\textwidth]{images/Exposee_graphik_Webapp}
  \end{center}
  \caption{Vesseltracker\_Webapplikation}
\end{wrapfigure}

Vesseltracker.com unterhält ein Netzwerk von ca. 800 terrestrischen AIS-Antennen, mit denen küstennahe AIS-Meldungen empfangen und via Internet an einen zentralen Rohdatenserver geschickt werden. Der Rohdatenserver verarbeitet die Meldungen und gibt sie umgewandelt und gefiltert an die Anwendungen des Unternehmens weiter.
Zusätzlich erhält das Unternehmen AIS-Daten via Satellit über einen Kooperationspartner. Damit werden die küstenfernen Meeresgebiete und Gegenden, in denen Vesseltracker.com keine AIS-Antenne betreibt, abgedeckt.
Die Kernanwendung des Unternehmens ist eine Webanwendung, die die terrestrischen AIS-Daten in einer Geodatenbank speichert und sie mit den Schiffs-Stammdaten und Satelliten-AIS-Daten in Beziehung setzt.

Für eine geographische Visualisierung der Schiffspositionen existiert das sogenannte 'Cockpit', wo die Schiffe als Icons auf Openstreetmap-Karten dargestellt werden. Diese Karte zeigt jeweils alle Schiffe an, die sich in dem frei wählbaren Kartenausschnitt zu der Zeit befinden. Aktualisiert werden die Positionsinformationen jeweils bei Änderung des betrachteten Bereichs oder einmal pro Minute. Detailinformationen erhält der Nutzer durch ein Click-Popup über das Icon des Schiffes. Darüber kann er sich auch die gefahrene Route der letzten 24 h anzeigen lassen.


\begin{figure}[H]
  \centering
  \includegraphics[width=6in]{images/Cockpit_Elbe}
  \caption[Cockpit\_Elbe]{Cockpit\_Elbe}
\end{figure}

\section{Motivation für diese Arbeit}\label{s.Motivation für diese Arbeit}

Aus mehreren Gründen erscheint es angebracht, die geographischen Schiffspositionen nicht nur über die Cockpit-Anwendung anzubieten, sondern alternativ als real-time-Darstellung. 
\begin{itemize}

\item Aufgrund der herausragenden Qualität des vesseltracker.com Antennen-Netzwerks sind die verfügbaren AIS-Daten aktuell, aktualisieren sich kontinuierlich und erreichen eine hohe weltweite Abdeckung. Damit ist es möglich, die Schiffsverkehrslage beliebiger Häfen, Wasserstraßen, Küstengebiete weltweit und sekundengenau zu präsentieren. 

\item Ein Phänomen in der menschlichen Wahrnehmung lässt die geplante Anwendung sehr viel zweckmäßiger erscheinen als die bisherige Cockpit-Anwendung. Aufgrund der sogenannten Veränderungsblindheit oder “Change Blindness” werden Veränderungen an einem Objekt (in diesem Fall die Position eines Schiffs-Icons auf der Karte) in der Wahrnehmung überdeckt, wenn im selben Augenblick Veränderungen an der Gesamtsicht vonstatten gehen. Im Cockpit werden nach dem Laden neuer Positionsdaten alle Schiffsicons neu gerendert und unter Umständen Namens-Fähnchen gelöscht oder hinzugefügt, was zu einem kurzen “Flackern” führt. Dadurch ist es dem Betrachter nahezu unmöglich, die Positionsänderung eines Schiffes auf der Karte nachzuvollziehen.
  
\item Real-time-Anwendungen gewinnen zunehmend an Bedeutung. Ihre Verbreitung wird durch den Fortschritt der verfügbaren Webtechnologien auf breiter Basis unterstützt. Mitbewerber auf dem Markt für AIS-Daten (z.B. Fleetmon.com) bieten bereits Echtzeit-Darstellungen ihrer AIS-Daten an. Um in diesem Geschäftsfeld weiterhin eine Spitzenposition innezuhaben, ist eine Realtime zwingend erforderlich, in einem nächsten Schritt sicher auch als Anwendung für Mobile Devices.
\end{itemize}


\section{Aufbau der Arbeit}\label{s.Aufbau der Arbeit}
Im Kapitel 2 werden mögliche Anwendungs-Szenarien genauer beleuchtet und die funktionalen und nicht funktionalen Anforderungen an die geplante Anwendung herausgestellt. Anschließend wird die Systemarchitektur der geplanten Anwendung grob entworfen.
Kapitel 3.1 gibt eine kurze Einführung in die Websocket-Technologie, Kapitel 3.2 stellt die Programmiersprache Google Dart vor.
In Kapitel werden zunächst die Gründe für die getroffene Auswahl an Implementierungen dargelegt und anschließend die Vorgehensweise bei der Implementierung erläutert. Die Implementierungen werden auszugsweise vorgestellt.
Die ausgearbeiteten Implementierungen werden dann in Kapitel 5 getestet und nach verschiedenen Aspekten verglichen.
Kapitel 6 fasst die Ergebnisse zusammen.

%---------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Realtime-Schiffsverfolgung per AIS-Daten-Strom}\label{c.Realtime-Schiffsverfolgung per AIS-Daten-Strom}

\section{ Anwendungsfälle}\label{s.Anwendungsfälle}

Hafendienstleister wie Schlepper, Lotsen oder Festmacher verschaffen sich über einen Monitor einen Überblick über die Arbeitsvorgänge in ihrem jeweiligen Heimathafen, z.B. welche Schlepper welches Schiff schleppen, wo Lotsen an oder von Bord gehen, von welchen Tankern Schiffe betankt werden. Sie kontrollieren die eigenen Aufträge oder auch die der Mitbewerber.
Die Anwendung läuft hierbei eher statisch, das heißt Zoomstufe und Kartenausschnitt ändern sich nur selten. Es ist also notwendig, dass die Anwendung unabhängig von Aktionen des Nutzers sich laufend oder regelmäßig aktualisiert.

Reedereien beobachten das Einlaufen, Anlegen, Festmachen, Ablegen und Auslaufen ihrer Schiffe in entfernten Häfen, wo es keine Unternehmensniederlassung gibt. Zum Beispiel kontrollieren sie, wann, an welchen Liegeplätzen ein Schiff wie lange festmacht.
Dazu ist es zum einen notwendig, jederzeit auf eine geringe Zoomstufe heraus- und auf einen anderen Hafen wieder hineinzoomen zu können. Zum anderen soll die Anwendung Schnittstellen bieten, damit zusätzliche Informationen aus dem vesseltracker.com Datenpool (in diesem Fall Liegeplatzinformationen) von der Anwendung abgerufen werden können.

Weitere Anwendungsfälle sind Nutzer aus der Passagierschifffahrt, Schiffsfotografen oder Sicherheitsorgane (z.B. die Wasserschutzpolizei), bei denen die Beobachtung / Überwachung bestimmter Wasserverkehrswege oder Häfen von besonderem Interesse ist.

Die vesseltracker.com GmbH nutzt die Realime-Anwendung, um die vom Unternehmen angebotenen Daten zu präsentieren und zu bewerben. Dabei ist es wichtig, dass die Anwendung gesendete AIS-Signale im Schnitt in weniger als einer Sekunde auf dem Monitor als Position oder Positionsänderung darstellen kann und dass die Schiffsbewegungen fließend ohne das in der Einleitung beschriebene “Flackern” dargestellt werden. Damit kann vesseltracker.com die höhere Genauigkeit und Aktualität der eigenen Daten gegenüber denen anderer Anbieter herausstellen.

Die Anwendungsfälle verdeutlichen noch einmal, dass der zusätzliche Nutzen der Realtimeanwendung gegenüber der Cockpitanwendung nicht ausschließlich im Informationsgehalt liegt. Die Daten im Cockpit sind ja ebenfalls im Minutenbereich aktuell. Der Vorteil liegt vielmehr in der Lebendigkeit der Darstellung. Bewegte Darstellungen binden stärker und für einen längeren Zeitraum die Aufmerksamkeit des Betrachters.

\section{Beschreibung der Anforderungen}\label{s.Beschreibung der Anforderungen}

Die funktionalen Anforderungen sind:
\begin{itemize}

\item als Datenquelle sollen ausschließlich die vom Rohdatenserver als JSON-Datenstrom zur Verfügung gestellten AIS-Informationen dienen
\item Schiffe sollen an ihrer aktuellen (realtime) Position auf einer Karte im Browser dargestellt werden
\item Positionsänderungen einzelner Schiffe sollen ad hoc sichtbar gemacht werden
\item die Schiffsbewegungen auf der Karten sollen nicht sprunghaft, sondern fließend erscheinen (Animation der Schiffsbewegungen in dem Zeitraum zwischen zwei Positionsmeldungen)
\item die Karte soll in 16 Zoomstufen die Maßstäbe von 1:2000 bis 1: 200 Mio abdecken
\item Schiffe sollen auf der Karte als Icons dargestellt werden, die den Navigationsstatus und gegebenenfalls den Kurs wiederspiegeln
\item bei hoher Auflösung und ausreichend statischen AIS-Informationen soll ein Schiff als Polygon in die Karte eingezeichnet werden.
\item bei geringer Auflösung ist ein Überblick über die Verteilung der empfangenen Schiffe zu vermitteln
\item Detail-Informationen zu jedem Schiff sollen als Popups über das Icon abrufbar sein
\end{itemize}

Nicht funktionale Anforderungen sind:
\begin{itemize}
\item die von den Antennen empfangenen AIS-Daten sind mit minimaler Verzögerung (< 500 msec) auf der Karte darzustellen
\item die Anwendung sollte ca. 300 Verbindungen gleichzeitig erlauben und skalierbar sein
\item als Clients der Anwendung sollten die gängigsten Browser unterstützt werden (IE, Chrome, Firefox, Safari, Opera) 
\item die Implementierungen werden auf Github als privates repository gehalten
\item als Kartenmaterial sind die von vesseltracker gehosteten OpenstreetMap-Karten zu verwenden
\item verwendete Software-Module sollten frei zugänglich sein (open source) 
\item ein Prototyp der Anwendung soll schnell zur Verfügung stehen. Dieser Prototyp soll Mitarbeitern und Partnern ermöglichen, ihre Anforderungen genauer zu spezifizieren oder sogar neue Anforderungen zu formulieren. 
\end{itemize}

\section{Grobentwurf der Anwendung}\label{s.Grobentwurf der Anwendung}

\begin{wrapfigure}{r}{0.6\textwidth}
  \begin{center}
    \includegraphics[width=0.58\textwidth]{images/Exposee_graphik_Realtimeapp}
  \end{center}
  \caption{Architektur-Entwurf der Realtime Webapplikation}
\end{wrapfigure}
Die eingehende Schnittstelle der zu erstellenden Anwendung ist die Verbindung zum Rohdatenserver, die als TCP-Verbindung ausgeführt ist und einen JSON-Datenstrom liefert.
Die ausgehende Schnittstelle ist der HTTP-Client (Browser).
Zu erstellen ist also eine Client-Server-Anwendung, in der der Server zweifaches zu leisten hat, nämlich 
\begin{enumerate}
 \item eine tcp-socket-Verbindung zum Rohdatenserver zu unterhalten und
  \item eine bidirektionale Verbindung zum HTTP-Client zu halten, in der der Client jederzeit Änderungen des betrachteten Kartenausschnittes an den Server senden und der Server jederzeit den Client über relevante, aus dem JSON-Datenstrom ausgelesene, Schiffsbewegungen im betrachteten Kartenausschnitt informieren kann.
\end{enumerate}


%---------------------------------------------------------------------------------------------------------------------------------------------
\chapter{Grundlagen}\label{s.Grundlagen}
\section{Automatisches Informationssystem}\label{s.Automatisches Informationssystem (AIS)}
Das Automatic Identification System (AIS) ist ein UKW-Funksystem im Schiffsverkehr, das seit 2004 für alle Berufsschiffe über 300 BRZ in internationaler Fahrt und seit 2008 auch für solche über 500 BRZ in nationaler Fahrt verpflichtend eingeführt worden ist. Es soll dabei helfen, Kollisionen zwischen Schiffen zu verhüten und die landseitige Überwachung und Lenkung des Schiffsverkehrs zu erleichtern. Außerdem verbessert AIS die Planung an Bord, weil nicht nur Position, Kurs und Geschwindigkeit der umgebenden Schiffe übertragen werden, sondern auch Schiffsdaten (Schiffsname, MMSI-Nummer, Funkrufzeichen, etc.). AIS ist mit UKW-Signalen unabhängig von optischer Sicht und Radarwellenausbreitung.\\
Für die Nutzung von AIS ist ein aktives, technisch funktionsfähiges Gerät an Bord Voraussetzung, das sowohl Daten empfängt als auch Daten sendet. Für Schiffe der Berufsschifffahrt sind Klasse-A-Transceiver an Bord vorgesehen, für nicht ausrüstungspflichtige Schiffe genügen Klasse-B-Transceiver, die mit niedriger VHF-Signalstärke und weniger häufig senden.  \\
Die dynamischen Schiffsdaten (LAT, LON, COG, SOG, UTC) erhält der AIS-Transceiver vom integrierten GPS-Empfänger, bei Klasse A auch von der Navigationsanlage des Schiffes. Die Kursrichtung (Heading =  HDG) kann über eine NMEA-183-Schnittstelle vom Kompass eingespeist werden.

Die AIS-Einheit sendet schiffsspezifische Daten, die von jedem AIS-Empfangsgerät in Reichweite empfangen und ausgewertet werden können:
Statische Schiffsdaten: 
\begin{itemize}
\item IMO-Nummer
\item Schiffsname
\item Rufzeichen
\item MMSI-Nummer
\item Schiffstyp (Frachter, Tanker, Schlepper, Passagierschiff, SAR, Sportboot u. a.)
\item Abmessungen des Schiffes (Abstand der GPS-Antenne von Bug, Heck, Backbord- und Steuerbordseite)
\end{itemize}

Dynamische Schiffsdaten
\begin{itemize}
\item Navigationsstatus (unter Maschine, unter Segeln, vor Anker, festgemacht, manövrierunfähig u. a.)
\item Schiffsposition (LAT, LON, in WGS 84)
\item Zeit der Schiffsposition (nur Sekunden)
\item Kurs über Grund (COG)
\item Geschwindigkeit über Grund (SOG)
\item Vorausrichtung (HDG)
\item Kursänderungsrate (ROT)
\end{itemize}

Reisedaten
\begin{itemize}
\item aktueller maximaler statischer Tiefgang in dm
\item Gefahrgutklasse der Ladung (IMO)
\item Reiseziel (UN/LOCODE)[5]
\item geschätzte Ankunftszeit (ETA)
\item Personen an Bord
\end{itemize}

Der Navigationsstatus und die Reisedaten müssen vom Wachoffizier manuell aktualisiert werden. Gesendet werden die AIS-Signale auf zwei UKW-Seefunkkanälen (Frequenzen 161,975 MHz und 162,025 MHz), wobei die Sendeintervalle abhängig sind von der Klasse, dem Manöverstatus und der Geschwindigkeit.

\begin{table}[!hbt]\vspace{1ex}\centering
\begin{tabular}{|l|l|l|l|}\hline
Klasse &Manöver-Status & Geschwindigkeit &Sendeintervall\\\hline\hline
Class A&geankert/festgemacht&<3kn&3 min\\
Class A&geankert/festgemacht&>3kn&10 sec\\
Class A&in Fahrt&0-14kn&10 sec\\
Class A&in Fahrt, Kursänderung&0-14&3 1/3 sec\\
Class A&in Fahrt&14-23kn&6 sec\\
Class A&in Fahrt, Kursänderung&14-23&2 sec\\
Class A&in Fahrt&>23kn&2 sec\\
Class B&&<2 kn&3 min\\
Class B&&>2 kn&30 sec\\\hline
\end{tabular}
\caption[Intervalle, in denen ein Schiff seine Daten aussendet] {Intervalle, in denen ein Schiff seine Daten aussendet}
\end{table}

Für AIS-Daten sind 22 standardisierte Nachrichtentypen bzw. Telegramme festgelegt:
In dieser Arbeit werden nur Class A Positionsmeldungen betrachtet (Typ 1-3) un.
\begin{table}[!hbt]
\centering
\begin{tabular}{|l|l|}\hline
ID&Nachrichtentyp\\\hline\hline
1& reguläre Positionsmeldung eines Klasse-A-Transceivers\\
4 & Meldung einer Basisstation\\
5& reguläre Meldung von Schiffs- und Reisedaten eines Klasse-A-Transceivers\\
9 & Positionsmeldung eines SAR-Luftfahrzeuges\\
12& sicherheitsbezogene Nachricht - adressiert\\
14& sicherheitsbezogene Nachricht - an alle\\
18& reguläre Positionsmeldung eines Klasse-B-Transceivers\\
21& Positions- und Statusmeldung eines AtoN-Transceivers\\\hline
\end{tabular}
\caption[Die wichtigsten AIS-Telegrammtypen] {Die wichtigsten AIS-Telegrammtypen}
\end{table}

Zur landseitigen AIS-Infrastruktur gehören sogenannte AIS-Basisstationen und AIS-Empfänger. Basisstationen dienen einerseits zur Erfassung des Verkehrs in dem von ihnen abgedecken Seegebiet, andererseits können diese Geräte die Übertragung von AIS-Transceivern an Bord gezielt steuern (z.B. Hochsetzen der Melderate). AIS-Empfänger sind reine AIS-Empfangsgeräte, die keine Daten senden.\\


\section{Bidirektionale Kommunikation über HTML5 Websockets}\label{s.Websockets}
In der Entwicklung der Kommunikationstechnologien im Internet galt lange Zeit das request/response Paradigma, nach dem Anfragen vom Client vom Server beantwortet werden. Dieses Paradigma wird Stück für Stück aufgebrochen durch kontinuierliche Weiterentwicklungen in Richtung einer bidirektionalen Kommunikation zwischen Server und Client.\\
Schon seit HTTP Long Polling, HTTP Streaming und Ajax on demand ist es für Serveranwendungen möglich nach einem initialen Verbindungsaufbau durch den Client, beim serverseitigen Eintreffen neuer Daten scheinbar selbständig einen Datenaustausch zum Client zu initieren. Dabei handelt es sich eigentlich nur um einen aufgeschobenen response auf einen zuvor gestellten client-Request.\\
Der Nachteil dieser Technologien liegt darin, dass sie, weil sie Nachrichten über das HTTP-Protokoll austauschen, einen großen Überhang an Header-Informationen mitzusenden gezwungen sind, der sich in Summe negativ auf die Latenzzeit auswirkt. Damit sind diese Technologien für zeitkritische (realtime) Anwendungen nicht unbedingt geeignet.
\\
Das 2011 eingeführte Websocket-Protokoll dagegen spezifiziert eine API (HTML5-Websocket API-Spezifikation), die eine echte bidirektionale Socket-Verbindung zwischen Server und Client ermöglicht, in der beide Seiten jederzeit Daten schicken können. Dieser Socket wird im Anschluss an einen intialen HTTP-handshake aufgebaut, indem Server und Client  einen Upgrade der Verbindung auf das Websocket-Protokoll aushandeln. 

\section{Node.js}\label{Node.js}
Node.js ist ein Framework zur Entwicklung serverseitiger Webanwendungen in Javascript. Es wurde 2009 von Ryald Dahl veröffentlich und hat seitdem viel Aufmerksamkeit erregt, weil Anwendungen in node.js
\begin{itemize}
 %\itemsep0em
\item hoch performant
\item skalierbar
\item und echtzeitfähig sind.
\end{itemize}
Diese Eigenschaften sind größtenteils dem Konzept des asynchronen, nicht blockierenden I/O von javascript im Allgemeinen und node.js im Besonderen geschuldet.
Javascript ist von Anfang asynchron konzipiert für die Verwendung im Webbrowser, wo synchrone Verarbeitung wegen der Verzögerung des Seitendarstellung nicht in Frage kommt. Den gleichen Ansatz übernimmt node.js für die Serverseite.
\\
Node.js arbeitet single-threaded und eventbasiert. Die zentrale Kontrollstruktur, die den Programmablauf steuert, ist der Event-Loop. Er empfängt Events, die von Programm- oder Nutzeraktionen ausgelöst werden und setzt sie in Callback-Funktionen um.
Kommt es im Programmablauf zur Interaktion mit einer externen Ressource, wird diese Interaktion in einen neuen Prozess ausgelagert und mit einer Callback-Methode versehen. Anschließend kann der Event Loop weitere aufgelaufene Events verarbeiten. Ist die Interaktion abgeschlossen bekommt der Event Loop ein Signal und setzt beizeiten die Verabeitung mit der entsprechenden Callback-Methode  fort.\\
Node.js bringt als Laufzeitumgebung die V8-Javascript-Engine mit, die die Ausführung von javascript-code durch Just-In-Time-Kompilierung optimiert. Außerdem bietet node.js eine direkte Unterstützung für das HTTP-Protokoll Websockets. Mit der Unterstützung des JSON-Datenformats sind alle notwendigen Bausteine zusammen für skalierbare, echtzeitfähige Serveranwendungen.
Außerdem lassen sich mit dem Node Package Manager npm jederzeit weitere Pakete aus dem wachsenden Angebot nachinstallieren und verwalten.\\
Als konkrete Pakete für Websockets standen innerhalb von node.js zum Zeitpunkt der Implementierung (November 2012) die Bibliotheken websocket (https://github.com/Worlize/WebSocket-Node) und socket.io (http://socket.io) zur Verfügung. Die Bibliothek websocket genügt der HTML5-Websocket-Api-Spezifikation (s.o). Socket.io erweitert die Funktionalität des websockets um heartbeats, timeouts and disconnection support. Außerdem kapselt socket.io die Details des Nachrichtenaustauschs: Bei Browsern, die Websockets nicht unterstützen, handelt socket.io die bestmögliche Verbindungsalternative aus in der Reihenfolge: 
-->    WebSocket 
 -->   Adobe® Flash® Socket
  -->  AJAX long polling
   --> AJAX multipart streaming
 -->   Forever Iframe
 -->   JSONP Polling
.

\section{Google Dart}\label{s.Google Dart }

\subsubsection{Motivation für Dart}
Dart ist eine von der Firma Google als OpenSource Projekt seit ca. 2 Jahren explizit für Webanwendungen entwickelte Programmiersprache. Das Ziel ist es, eine Sprache zu entwickeln, die komplexe Webanwendungen besser unterstützt als Javascript mit seinen historisch bedingten Ungereimtheiten und Schwächen.
Das Entwicklerteam definiert die Design-Ziele folgendermaßen:
Dart soll
\begin{itemize}   
\item eine sowohl strukturierte als auch flexible Web-Programmiersprache sein
\item sich für Programmierer vertraut anfühlen und intuitiv erlernbar sein 
\item mit seinen Sprachkonstrukten performant sein und schnell zur Ausführung kommen
\item auf allen Webdevices wie Mobiles, Tablets, Laptops und Servern gleichermaßen lauffähig sein
\item alle gängigen Browser unterstützen.
\end{itemize}

\subsubsection{Spracheigenschaften von Dart}\label{s.Spracheigenschaften von Dart}
\begin{itemize}

\item Dart arbeitet {\bf ereignisbasiert} und {\bf asynchron} und in einem einzigen Thread ganz nach dem Vorbild von node.js.
\item  Dart läuft nativ in der {\bf Dart-Virtual-machine}, kann aber auch nach Javascript kompiliert werden.
 
\item {\bf Klassen } sind ein wohlbekanntes Sprachkonzept zur Kapselung und Wiederverwendung von Methoden und Daten. Jede Klassen definiert implizit ein Interface.
\item {\bf Optionale Typisierung:}
Die Typisierung in Dart ist optional, das heißt sie führt nicht zu Laufzeitfehlern. Sie ist als Werkzeug für den Entwickler gedacht, zur besseren Verständlichkeit des Codes und als Hilfe beim Debuggen.
\item Die  {\bf Gültigkeitsbereiche}
von Variablen in Dart gehorchen einfachen, intuitiv nachvollziehbaren Regeln: Variablen sind gültig in dem Block ({...}), in dem sie definiert sind.
\item
Zur {\bf Parallelverarbeitung} nutzt Dart das Konzept von Isolates (übernommen von ERLANG), eine Art Leightweigth Processes. Isolates greifen nicht auf einen gemeinsamen Speicherbereich zu teilen nicht denselben Prozessor-Thread. Isolates kommunizieren miteinander ausschließlich über Nachrichten (über SendPort und ReceivePort). Sie werden gesteuert von einem übergeordneten Event Loop.
\item Der {\bf DartEditor} ist eine Entwicklungsumgebung für die Entwicklung von Dart Web- und Serverapplikationen. Sie beinhaltet das {\bf Dart SDK } und den {\bf Dartium Browser} mit der {\bf Dart VM}.
\item Der {\bf dart2js Compiler} ist ebenfalls im DartEditor enthalten und kompiliert Dart-Code zu Javascript-Code, der für die Chrome V8 Javascript engine optimiert ist.
\item Mit {\bf Pub} verfügt Dart über einen Package Manager vergleichbar dem Node Package Manager npm.
\end{itemize}


\subsubsection{Einbindung von Javascript-Bibliotheken in Dart mit js-interop}\label{s.Einbindung von Javascript-Bibliotheken in Dart mit js-interop}
Für die Verwendung von Javascript-Bibliotheken in Dart-Code existiert die Dart-Bibliothek {\bf js-interop}. Damit können Dart-Anwendungen Javascript-Bibliotheken verwenden und zwar sowohl in nativem Dart code, der in der Dart-Virtual-Machine ausgeführt wird als auch in mit dart2js zu Javascript kompilierten Dart-Code.\\

Nachdem die Bibliothek in eine Dart-Anwendung eingebunden worden ist, kann ein sogenannter {\bf Proxy} zum javascript-Kontext der Seite erstellt werden. Referenzen an diesen Proxy werden automatisch zu Javascript umgeleitet. Auf oberster Ebene lassen sich damit Javascript-Arrays und -Maps generieren, die mit den entsprechenden Objekten in Dart korrespondieren. Über diesen Proxy können aber auch Proxies zu beliebigen Javascript-Objekten erstellt werden, deren Eigenschaften und Methoden im Javascript-Scope zur Verfügung stehen.\\

Um Dart-Funktionen aus dem javascript-Scope heraus aufzurufen, wird die entsprechende Funktion in ein {\bf Callback-Objekt} umgewandelt, das entweder ein einziges Mal oder mehrmals aufrufbar ist. Um die Lebensdauer dieser Proxies und Callback-Objekte zu verwalten benutzt Dart das Scope-Konzept: Per default haben alle proxies nur lokale Gültigkeit. Sollen sie den Ausführungszeitraum des Scopes überdauern, können sie ausdrücklich aufbewahrt werden, müssen dann aber zu Vermeidung von memory leaks auch explizit wieder freigegeben werden. Dasselbe gilt für Callback-Objekte, die mehrmals aufrufbar sind.

\subsubsection{Dart-Websockets}
Für serverseitiges Dart, das auf der serverseitigen Dart-VM läuft existiert das Paket Dart:io. Es ermöglicht Zugriff auf das Dateisystem und auf Prozesse. In Dart:io existiert auch eine Websocket-Implementierung, mit der bereits einfache Websocket-Server geschrieben werden können.


\section{NoSQL-Datenbanken}
\subsection{MongoDB}
\subsection{Redis}

%---------------------------------------------------------------------------------------------------------------------------------------------



\chapter{Implementierungen}\label{s.Implementierungen}

\section{Implementierungsplan}
\subsection{Lösung in Javascript}
Zunächst wird eine Implementierung gewählt, die die besten Chancen hat, alle Anforderungen zu erfüllen. Diese steht im Zeitplan ganz vorne, um der Anforderung von Unternehmensseite nach einer zeitnahen Umsetzung und Auslieferung zu entsprechen.
Dies ist eine Lösung in Javascript mit dem node.js-Framework und dem socket.io-Websocket. Node.js-Serveranwendungen werden schon länger mit guten Ergebnissen in Netzwerken eingesetzt, besonders für Realtime-Anwendungen und vielen gleichzeitig verbunden Clients. Das socket.io-Paket wird genutzt, weil durch die Kapselung der verschiedenen Transportmechanismen die Bedienung einer maximalen Anzahl an Browser-Clients möglich ist, ohne den Implementierungsaufwand unverhältmismäßig zu erhöhen.
\subsection{Lösung in Google Dart}
In einem zweiten Schritt wird eine vergleichbare Implementierung in Google Dart ausgeführt. Die Entwicklung von Dart befindet sich noch in der Beta-Phase. Der zweite Beta-Release fand im Dezember 2012 statt. Ein dritter Beta-Release ist angekündigt. Ein zeitnaher ausschließlicher Einsatz von Dart im Produktivsystem ist somit ausgeschlossen und diese Lösung ist als Investition in die Zukunft zu sehen. 
Der Vergleich beider Implementierungen (Javascript vs. Dart) ist deshalb nicht weniger interessant.   
\subsubsection{Schwerwiegende Probleme bei der Implementierung in Dart}
Der ursprüngliche Plan, sowohl Server als auch Client in Dart zu schreiben, musste korrigiert werden, weil mit dem Dart-Websocket-Server einige der grundlegenden Anforderungen nicht umzusetzen waren. Zum einen unterstützt Dart keine JSON-over-TCP -Kommunikation, wie sie für die Abfrage der Daten vom Rohdatenserver erforderlich ist. Und zum anderen gab es noch keinen Redis-Client für Dart. Der publish/subscribe Mechanismus der Redis-Datenbank wird für die Verteilung der Positionsupdates benötigt.
Deshalb wird nur der Client in Dart implementiert. Damit taucht auch schon das nächste Problem auf: der socket.io-Websocket-Server entspricht nicht der HTML5-Websocket-API-Spezifikation und benötigt deshalb auf Clientseite zusätzliche Bibliotheken. Diese Bibliotheken stehen in Dart nicht zur Verfügung. Dart unterstützt Websocketverbindungen clientseitig mit dem Paket dart:html unterstützt. Darin wird ein HTML5-Websocket erwartet.
Folglich muss neben dem socket.io-Server ein zweiter Server (in Javascript) implementiert werden, der eine Websocket-Verbindung nach der HTML5-Websocket-API-Spezifikation aufbaut. Dies ist relativ einfach  möglich: in node.js kann hierfür das Modul websocket eingebunden werden.
\subsubsection{Vergleichbarkeit}
An dieser Stelle stellt sich die Frage, ob beide Lösungen direkt vergleichbar sind. Mögliche Unterschiede zwischen den node.js-Servern (socket.io vs. HTML5) würden in das Ergebnis des Vergleichs zwischen den Clients (Dart vs Javascript) einfliessen. Deshalb wird der Javascript-Client noch einmal mit dem HTML5-Websocket implementiert, der dann auf denselben HTML5-Websocket-Server zugreift wie der Dart-Client (siehe Tabelle). 
Es werden also zwei Vergleiche durchgeführt: 
\begin{itemize}
\item In Javascript wird der socket.io-Websocket gegen den HTML5-Websocket getestet.
\item Unter Verwendung des HTML5-Websockets wird der Javascript-Client gegen den Dart-Client getestet
\end{itemize}
Zur besseren Übersicht habe ich die Implementierungen in einer Tabelle zusammengefasst.
Auf diese Weise wird die präferierte Lösung in node.js mit socket.io (S1) nicht unmittelbar sondern mittelbar über die Javascript-Lösung mit HTML5-Websocket (H1) gegen die mögliche Implementierung mit einem Google Dart Client (H2) getestet.
\renewcommand{\arraystretch}{1.2}

\begin{table}[!hbt]\vspace{1ex}\centering
\begin{tabular}{| l| m{2.3cm}||c|c|}\cline{3-4}

\multicolumn{2}{c||}{}&\multicolumn{2}{c|}{HTTP-Client}\\\cline{3-4}
\multicolumn{2}{c||}{}& Javascript& Google Dart\\\hline\hline
\multirow{2}*{\rotatebox{90}{HTTP-Server}}& socket.io websocket-Server&  socket.io (S1) & \includegraphics[width=0.2in]{images/x_red.jpeg}\\\cline{2-4}
&HTML-5 websocket-Server & HTML5 (H1) & HTML5(H2)\\\hline
\multicolumn{4}{c}{}\\
\end{tabular}
\caption[Übersicht über Server-und Clientimplementierungen]
{Übersicht über Server-und Clientimplementierungen\\}
\vspace{2ex}
\end{table}
\newpage

\section{Implementierung des Prototypen in Javascript}
In dieser ersten Implementierung werden Lösungen entwickelt für die in den Anforderungen beschriebenen Aufgaben. In der Vergleichsimplementierung werden diese Lösungen übernommen und wo das nicht möglich ist, wird eine Alternative entwickelt und dies an der jeweiligen Stelle angemerkt.

\subsection{socket.io-Server}
Die zu entwickelnde Serveranwendung hat die Aufgabe, eine JSON-over-TCP-Verbindung zum Rohdatenserver aufzubauen und die Daten über Websocket-Verbindungen an die Clients weiterzugeben.
Weil Node.js singlethreaded ist (\ref{s.Nodejs-Websockets}) würden beide Aufgaben in einem einzigen Prozess bearbeitet. Um das Potential an Parallelverabeitung eines Dualcore oder Multicore-Servers zu nutzen, ist des daher sinnvoll, mindestens zwei Prozesse zu generieren. Dazu wurde das node.js-Modul child\_process genutzt. Die ausführbare Datei master.js generiert damit zuerst einen Prozess, der den AIS-Client (ais\_client.js) startet, um Daten vom Rohdaten-Server abzufragen und anschließend einen Prozess (worker.js), um einen Websocket -Server für Client-Verbindungen zur Verfügung zu stellen (\ref{s.master.js}).
\begin{lstlisting}[caption=Generierung von Kindprozessen in master.js, firstnumber=16, label=s.master.js]
/* AIS-Client - Process*/
function forkAISClient() {
  var errors;
  try {
    child.fork(path.join(__dirname, 'ais_client.js'));
  }
  catch (err) {
    errors = true;
    log('Error forking AIS client process: ' + err);
    log('Exiting ...');
    process.exit(1);
  }
  if (errors == null) log('Forked AIS client process');

  forkWorker();
}

/*worker- Process*/
function forkWorker(){
  var errors;
  try
  {
    child.fork(path.join(__dirname, 'worker.js'));
  }
  catch (err) {
    errors = true;
    log('Error forking worker process: ' + err);
    log('Exiting ...');
    process.exit(1);
  }
  if (errors == null) log('Forked worker process');
}
\end{lstlisting}
Bei der Weitergabe der Daten durch den worker-Prozess sind zwei Fälle zu unterscheiden:
\begin{itemize}
\item ein Client verbindet sich neu oder ändert den Kartenausschnitt \\
in diesem Fall sind alle im Bereich befindlichen Positionsdaten zu senden (vessel-in-Bounds Request)
\item ein Schiff, das sich im beobachteten Kartenausschnitt eines oder mehrerer Clients befindet sendet ein Positions-Update (vessel-Position-Event)\\
in diesem Fall sind alle Clients, deren Kartenausschnitt die betreffende Schiffsposition enthält, zu informieren.
\end{itemize}
Der erste Fall macht eine Zwischenspeicherung der Daten unumgänglich. Wegen der großen Anzahl gleichzeitig empfangener Schiffe (weltweit ca. 60.000) und der Notwendigkeit, einen geographischen Index zu verwenden wird einer persistenten gegenüber einer transienten Speicherung der Vorzug gegeben. 
\\Für die Persistierung wird hier MongoDB verwendet, weil MongoDB als NoSQL-.Datenbank einen geringen Overhead, schnelle Antwortzeiten und einen geographischen Index bietet. Der Serverprozess in ais\_client.js schreibt die Daten. Dabei ist die MMSI eines Schiffes eindeutig und wird als unique key verwendet (s.o.). Über die Option upsert:true wird der Mongo Datenbank mitgeteilt, dass entweder ein insert oder, falls mmsi bereits vorhanden das set upgedated werden soll (). 
\begin{lstlisting}[caption=Schreiben in die Datenbank in ais\_client.js, firstnumber=321]
vesselsCollection.update(
  { mmsi: obj.mmsi },
  { $set: obj },
  { safe: false, upsert: true }
  );
\end{lstlisting}
Derselbe Prozess unterhält den Geo-Index ().
\begin{lstlisting}[caption=Aufbau des Geo-Indexes in ais\_client.js, firstnumber=218]
function ensureIndexes() {
  log('(MongoDB) Ensuring indexes ... ')
  vesselsCollection.ensureIndex({ pos: "2d", sog: 1, time_received: 1 }, function(err, result) {
    if (err) {
      log(err);
    }
    else {
      log('(MongoDB) Ensuring index ' + result);
    }
  });
  ...}
  \end{lstlisting}
Der Serverprozess worker.js liest die Daten für die vom Client übermittelten Geo-Daten aus().
  \begin{lstlisting} [caption=query in worker.js, firstnumber=220]
 function getVesselsInBounds(client, bounds, zoom) {
   var timeFlex = new Date().getTime();
   var vesselCursor = vesselsCollection.find({
    pos: { $within: { $box: [ [bounds._southWest.lng,bounds._southWest.lat], [bounds._northEast.lng,bounds._northEast.lat] ] } },
    time_received: { $gt: (new Date() - 10 * 60 * 1000) },
    $or:[{sog: { $exists:true },sog: { $gt: zoomSpeedArray[zoom]},sog: {$ne: 102.3}},/*{msgid:4},*/{ $gt:{msgid: 5}}]
  });
  vesselCursor.toArray(function(err, vesselData) 
  {
    var boundsString = '['+bounds._southWest.lng+','+bounds._southWest.lat+']['+bounds._northEast.lng+','+bounds._northEast.lat+']';
    if (!err)
    {
     console.log('(Debug) Found ' + vesselData.length + ' vessels in bounds ' + boundsString +" with sog > "+zoomSpeedArray[zoom]);
          client.sendUTF(JSON.stringify({ type: 'vesselsInBoundsEvent', vessels: vesselData}));
    }
   ...
  });
}
\end{lstlisting}
Also speichert der Server alle als JSON empfangenen Datensätze in einer MongoDatenbank und liest sie aus, sobald ein vessel-in-Bounds Request vom Client gestellt wird. 



Der zweite Fall macht eine Speicherung der Clients auf Serverseite unumgänglich. Die Serveranwendung muss bei jeder Positionsmeldung wissen, welche Clients benachrichtigt werden müssen. 


Der Datenaustausch zwischen beiden Prozessen funktioniert über zwei nosql-Datenbanken. In einer mongo-Datenbank werden alle vom ais\_client-Prozess empfangen Positions- und Reisedaten  unter der mmsi eines Schiffes gespeichert. Dabei wird die upsert-Option von Mongo genutzt, so dass nicht vorhandene Schiffe eingefügt und vorhande aktualisiert werden.

Der worker-Prozess greift auf die Mongo-Datenbank zu, um für einen vom Client angefragten Kartenausschnitt die entsprechenden Schiffe abzufragen. Dabei wird der in Mongo zur Verfügung stehende Geo-Index auf der Schiffsposition verwendet.

Zur Verteilung der Positionsmeldungen (msgid 1,2 und3)  wird außerdem eine Redis-Datenbank verwendet, die über einen publish/subscribe-Mechanismus verfügt. Über einen Kanal "vesselpos" publiziert der AIS-Client-Prozess die Positionsmeldungen und der worker-Prozess meldet sich am selben Kanal an und wird über jede Positionsmeldung benachrichtigt, die er an seine verbunden Websocket-Clients weiterreichen kann.

\subsection{socket.io-Client}
Der zugehörige Client (socket.io-Client) wird ebenfalls in Javascript implementiert und bindet die socket.io-Bibliotheken ein. Das socket.io Paket bietet Features wie die interne Clientverwaltung durch den Websocket.

\section{Vergleichsimplementierung in Google Dart}

Nachdem die Anwendung als Prototyp in Javascript fertiggestellt ist, soll eine vergleichbare Implementierung in Google Dart realisiert werden. Das paket dart:io bietet die entsprechende Unterstützung für HTML5-Websocket-Server und dart:html für HTML5-Websocket-Clients.
Allerdings ergeben sich auf der Serverseite einige schwerwiegende Probleme:
- zum Zeitpunkt der Umsetzung (Dezember 2012) fehlt noch ein Redis-Client in Dart, so dass für die publish/subscribe-Lösung mit Redis [siehe] eine Alternative entwickelt werden müsste, die wiederum die Vergleichbarkeit beider Implementierungen herabsetzt.
- der socket.io-Server nutzt 'JSON over TCP', um die Daten vom Rohdatenserver abzufragen. 'JSON over TCP' ist in Dart (noch) nicht implementiert. Ohne die Schnittstelle zum Rohdatenserver zu verändern ist also keine vergleichbare Lösung in Dart umsetzbar.

Der Vergleich zwischen der Javascript- und der Google Dart-Anwendung ist also zu diesem Zeitpunkt lediglich auf der Clientseite möglich beziehungsweise sinnvoll. 


\subsection{HTML5-Server}

Für den HTML5-Server ist es nun möglich, zwei vergleichbare HTML5-Websocket-Clientanwendungen jeweils in Javascript (js-client) und Dart (dart-client) zu bauen, die beide eine Websocketverbindung nach der HTML5-Spezifikation zum HTML5-Server aufbauen.

\subsection{js-Client}
Die Funktionalität entspricht exakt der des socket.io-Clients. 

\subsection{dart-Client}nicht unterstützt
Zum Schluß wird der Client für den HTML5-Server in Dart geschrieben. 




\chapter{Vergleichende Evaluation}
Die realisierten Implementierungen lassen zwei Vergleiche zu: 
\begin{itemize}
\item Node.js-server mit socket.io-Websocket-Server vs. node.js-Server mit HTML5-Websocket-Server, wobei die Javascript-Clients sich nur marginal unterscheiden.
\item Javascript-Client vs. Dart-Client, wobei beide auf denselben node.js-Server mit HTML5-Websocket-Server zugreifen
\end{itemize}

\section{Socket.io-Websocket vs. HTML5-Websocket}
\subsection{Implementierungsaufwand}
Anzahl zeilen code

\subsection{Latenzzeit}
querytime

time received
\begin {figure}[H]
\begin{center}
  \includegraphics[width=4.5in]{images/latency_timeReceived_socket_io.png}
\end{center}
\caption{socket.io-Websocket-Server: Latenzzeit der Positionsmeldungen und Anzahl empfangener Schiffe}
\end {figure}

\begin {figure}[H]
\begin{center}
  \includegraphics[width=4.5in]{images/latency_timeReceived_HTML5.png}
\end{center}
\caption{HTML5-Websocket-Server: Latenzzeit der Positionsmeldungen und Anzahl empfangener Schiffe}
\end {figure}


\subsection{Performance}
paintToMap

\subsection{Browserunterstützung}
Firefox, Chrome, IE, Safari


\section{Javascript-Client vs. Dart-Client} 
\subsection{Implementierungsaufwand}

\subsubsection{js-Client}
Zeilen Code



\subsection{Latenzzeit}
queryTime

\subsection{Performance}
paintToMap
\newpage

\begin {figure}[H]
\begin{center}
  \includegraphics[height=2.3in]{images/Dartium.png}
\end{center}
 \caption{Dauer des Renders in Dartium}
\end {figure}


\begin {figure}[H]
\begin{center}
  \includegraphics[height=2.3in]{images/Chrome.png}
\end{center}
 \caption{Dauer des Renders in Chrome}
\end {figure}


\begin {figure}[H]
\begin{center}
  \includegraphics[height=2.3in]{images/Firefox.png}
\end{center}
 \caption{Dauer des Renders in Firefox}
\end {figure}


\subsection{Browserunterstützung}
\subsubsection{Dartium}

\subsubsection{Firefox, Chrome, IE, Safari}

Der dart-Client kompiliert den in Dart geschriebenen Code zu Javascript.

Dabei traten Fehler auf, die unter Dartium (also im originalen Dart-Code) nicht auftraten.
1. Wird innerhalb des Javascript-Scopes eine Methode auf einen javascript-Proxy (hier \_map) aufgerufen und ein proxy wird zurückgegeben, dann ist es nicht möglich auf diesen Proxy, der in diesem Fall vom Typ LatLngBounds sein müsste, eine Methode der Klasse LatLngBounds aufzurufen. => TypeError: t1.get\$\_map(...).getBounds\$0(...).getSouthWest\$0 is not a function

dart-client: web/leaflet\_maps.dart

  List getBounds(){
    var south, west, north, east;
    js.scoped((){
    south= \_map.getBounds().getSouthWest().lng;
        west = \_map.getBounds().getSouthWest().lat;
        north = \_map.getBounds().getNorthEast().lng;
        east = \_map.getBounds().getNorthEast().lat;
 });
return [west, south, east, north];
    
In diesem Fall wird einfach als work-Around eine andere Methode verwendet (getBBoxString), die einen String mit den Bounds zurückgibt. Aus den Teilen dieses Strings werden mit der Methode parse(string) der Klasse double die Werte der Eckpunkte der Bounds generiert.

String getBounds(){
    String bBox;
    js.scoped((){
      bBox = \_map.getBounds().toBBoxString();
    });
    return bBox;
  }

 Weil dadurch der message-Parameter 'bounds' kein number-Array, sondern ein String ist, muss im html5-Server der String einmal zum Float geparst werden.



2. Ein Feld ("IMO") wird auf null und auf > 0 geprüft.


\chapter{Fazit}\label{c.Fazit}

 \section{Ergebnisse }

\section{Ausblick}
-Satellitendaten in die Anwendung einbinden

\bibliographystyle{alphadin_martin}
%\bibliography{bibliographie}
\begin{thebibliography}{999}
	\bibitem{Ladd12} Seth Ladd, "Sorry, at the time of this writing, I'm not aware of a socket.io port for Dart. socket.io is nice because it has a bunch of implementation options for browsers that don't support Web sockets. Sounds like a good idea for a hackathon project!",2012 Oct 15,  http://stackoverflow.com/questions/12882112/is-there-a-socket-io-port-to-dart.
\bibitem{}
\bibitem{}http://nbn-resolving.de/urn:nbn:de:swb:14-1114955960020-08344


\end{thebibliography}

%---------------------------------------------------------------------------------------------------------------------------------------------
\chapter*{Erklärung}

Hiermit versichere ich, dass ich die vorliegende Arbeit selbstständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe, dass alle Stellen der Arbeit, die wörtlich oder sinngemäß aus anderen Quellen übernommen wurden, als solche kenntlich gemacht und dass die Arbeit in gleicher oder ähnlicher Form noch keiner Prüfungsbehörde vorgelegt wurde.

\vspace{3cm}
Ort, Datum \hspace{5cm} Unterschrift\\

\end{document}